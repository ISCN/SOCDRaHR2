---
title: "CPEAT 875 datasets ingestion"
author: "Vaasuki Marupaka"
date: "2023-06-20"
output: html_document
---

```{r}
# install.packages('pangaear')
# install.packages('dplyr')
library(tidyverse)
library(pangaear) # see package details at https://github.com/ropensci/pangaear
library(dplyr) # set of tools for data manipulation, see details at https://dplyr.tidyverse.org/

source('../R/readCPEAT.R')
```


```{r}
byCore.ls <- readCPEAT(dataDir = 'Downloads', format = 'byCore')

byType.ls <- readCPEAT(dataDir = 'Downloads', format = 'byDataType')

```

```{r}
allCores.df %>%# mutate(across(.cols = everything(), function(xx){!is.na(xx)})) %>%
  reframe(across(.cols = everything(), function(xx){sum(!is.na(xx))})) %>%
  t() 
```


```{r}
#loop for the Age determination classification 
#PAGES_AgeDetermination_data <- data.frame()
#my_all_names <- c()

temp_AgeD <- plyr::ddply(PAGES_AgeDetermination, c("doi","citation"), .fun = function(xx) {
  all_AgeD_data <- pg_data(doi = xx$doi, overwrite = FALSE) # difficult to interpret if using the clumn indexing with number 
  all_AgeD_data <- all_AgeD_data[[1]]$data
  # add columns identifying unique source of data for further attribution
  return(all_AgeD_data)
}) 


# for (i in 1:nrow(PAGES_AgeDetermination)) { # tried with smaller dataset from 32:64 rows earlier
#   # using pg_data will automatically download the .tab format of the datasets (metadata + data) in the cache folder
#   all_AgeD_data <- pg_data(doi=PAGES_AgeDetermination[i,2])
#   print(all_AgeD_data)
#  # print(pg_data(doi=PAGES_AgeDetermination[i,2])) # this was adding more time to run
#   print(i)
#   all_AgeD_data <- all_AgeD_data[[1]]$data
#   #if (is.numeric(all_AgeD_data$`Lab label`)) {
#    #all_AgeD_data <- rename(all_AgeD_data, `Lab label(chr)` = `Lab label`)
#   #}
#   # add columns identifying unique source of data for further attribution
#   all_AgeD_data$DOI <- as.character(PAGES_AgeDetermination[i,2])
#   all_AgeD_data$citation <- as.character(PAGES_AgeDetermination[i,5])
#   my_all_names <- union(my_all_names, names(all_AgeD_data))
#   #print(names(all_AgeD_data))
#   #PAGES_AgeDetermination_data <- bind_rows(PAGES_AgeDetermination_data, all_AgeD_data)
# }

# renaming columns probably might not help
# compare the column names across the datasets! <- ignore 
# look up names repair function in r
# look into ldply function [get rid of for loop]
# create a test data frame or tibble with two columns with the same name [maybe 3*3], use name_repair function to fix that -> to give an integer to the same name column  
# try applying it to line 83 if it works 
# try to find where the code is slow, and look for optimization 



write.table(PAGES_AgeDetermination_data, file=paste0(datapath,"PAGES_AgeDetermination_CPEAT.txt"), row.names = FALSE, quote = FALSE, sep = "\t", na = "")


allAgeData.ls <- plyr::dlply(PAGES_AgeDetermination[1:nrow(PAGES_AgeDetermination),], c("doi"), .fun = function(xx) {
  all_Age_data <- pg_data(doi = xx$doi, 
                          overwrite = FALSE) # difficult to interpret if using the column indexing with number 
  all_Age_data <- all_Age_data[[1]]
  # add columns identifying unique source of data for further attribution
  return(all_Age_data)
}) 

all_Age_Cores.df <- plyr::ldply(allAgeData.ls, .fun = function(xx) {
  return(xx$data)
}) 


all_Age_Study.df <- plyr::ldply(allAgeData.ls, .fun = function(xx) {
  primaryNames <- intersect(names(xx), c('parent_doi', 'doi', 'citation', 
                                         'url', 'path'))
  if(any( ! (names(xx) %in% c(primaryNames, 'metadata', 'data')))){
    warning(paste('possible missing informatin at primary level for', xx$doi,
                  setdiff(names(xx), c(primaryNames, 'metadata', 'data'))))
  }
  ans.ls <- xx[primaryNames]
  
  metaNames <- intersect(names(xx$metadata), c("citation", "related_to", "further_details",
                                               "projects" , "coverage",
                                               "abstract", "keywords",
                                               "status",
                                               "license", "size", "comment"))
   if(any( ! (names(xx$metadata) %in% c(metaNames, 'events', 'parameters')))){
    warning(paste('possible missing informatin at metadata level for', xx$doi))
   }
   ans.ls <- c(ans.ls, xx$metadata[metaNames])
  
   eventsNames <- intersect(names(xx$metadata$events), c("LATITUDE", "LONGITUDE",
                                                         "ELEVATION", "ELEVATION START", "ELEVATION END",
                                                         "Penetration", "Recovery",
                                                         "LOCATION", "METHOD/DEVICE", 
                                                         "COMMENT"))
   if(any( ! (names(xx$metadata$events)[-1] %in%  
              c("LATITUDE", "LONGITUDE", "ELEVATION",
                "ELEVATION START", "ELEVATION END", 
                "Penetration","Recovery",
                "LOCATION", "METHOD/DEVICE", "COMMENT")))){
    warning(paste('possible missing informatin at metadata-events level for', xx$doi))
   }
   
   ans.ls <- c(list(core_name = names(xx$metadata$events)[1]),
               ans.ls, 
               xx$metadata$events[eventsNames])
   
  # add columns identifying unique source of data for further attribution
  return(as.data.frame(ans.ls, stringsAsFactors = FALSE))
})


test <- data.frame(header = names(allAgeData.ls[['10.1594/PANGAEA.890189']]$data), description = unlist(lapply(allAgeData.ls[['10.1594/PANGAEA.890189']]$metadata$parameters, paste, collapse = " ")), 
                    allAgeData.ls[['10.1594/PANGAEA.890189']]$doi)


# Something is wrong with the code base that each time it runs into an error
all_AgeParameters.df <-  plyr::ldply(allAgeData.ls, .fun = function(xx) {
             ParametersAge <- data.frame(header = names(xx$data), 
            description = unlist(lapply(xx$metadata$parameters, paste, collapse = " "))) 
            if(any( ! (names(xx$data) %in% 
                        names(xx$metadata$parameters)))){
                          warning(paste("Data and parameters lengths differ.", xx$doi))
                        }
})



```


```{r}
#loop for the Calibrated Age classification 
#PAGES_CalibratedAges_data <- data.frame()

# for (i in 1:nrow(PAGES_CalibratedAges)) {
#   # using pg_data will automatically download the .tab format of the datasets (metadata + data) in the cache folder
#   all_CalAge_data <- pg_data(doi=PAGES_CalibratedAges[i,2])
#   print(all_CalAge_data)
#   print(i)
#   all_CalAge_data <- all_CalAge_data[[1]]$data
#   # add columns identifying unique source of data for further attribution
#   all_CalAge_data$DOI <- as.character(PAGES_CalibratedAges[i,2])
#   all_CalAge_data$citation <- as.character(PAGES_CalibratedAges[i,5])
#   PAGES_CalibratedAges_data <- as.data.frame(bind_rows(PAGES_CalibratedAges_data, all_CalAge_data))
# }

write.table(PAGES_CalibratedAges_data, file=paste0(datapath,"PAGES_CalibratedAges_CPEAT.txt"), row.names = FALSE, quote = FALSE, sep = "\t", na = "")

temp_CalAge <- plyr::ddply(PAGES_CalibratedAges, c("doi","citation"), .fun = function(xx) {
  all_CalAge_data <- pg_data(doi = xx$doi, overwrite = FALSE) # difficult to interpret if using the clumn indexing with number 
  all_CalAge_data <- all_CalAge_data[[1]]$data
  # add columns identifying unique source of data for further attribution
  return(all_CalAge_data)
}) 

# NEW CODE 
all_CalData.ls <- plyr::dlply(PAGES_CalibratedAges[1:nrow(PAGES_CalibratedAges),], c("doi"), .fun = function(xx) {
  all_CalAge_data <- pg_data(doi = xx$doi, 
                          overwrite = FALSE) # difficult to interpret if using the column indexing with number 
  all_CalAge_data <- all_CalAge_data[[1]]
  # add columns identifying unique source of data for further attribution
  return(all_CalAge_data)
}) 

all_Cal_Cores.df <- plyr::ldply(all_CalData.ls, .fun = function(xx) {
  return(xx$data)
}) 


all_Cal_Study.df <- plyr::ldply(all_CalData.ls, .fun = function(xx) {
  primaryNames <- intersect(names(xx), c('parent_doi', 'doi', 'citation', 
                                         'url', 'path'))
  if(any( ! (names(xx) %in% c(primaryNames, 'metadata', 'data')))){
    warning(paste('possible missing informatin at primary level for', xx$doi,
                  setdiff(names(xx), c(primaryNames, 'metadata', 'data'))))
  }
  ans.ls <- xx[primaryNames]
  
  metaNames <- intersect(names(xx$metadata), c("citation", "related_to", "further_details",
                                               "projects" , "coverage",
                                               "abstract", "keywords",
                                               "status",
                                               "license", "size", "comment"))
   if(any( ! (names(xx$metadata) %in% c(metaNames, 'events', 'parameters')))){
    warning(paste('possible missing informatin at metadata level for', xx$doi))
   }
   ans.ls <- c(ans.ls, xx$metadata[metaNames])
  
   eventsNames <- intersect(names(xx$metadata$events), c("LATITUDE", "LONGITUDE",
                                                         "ELEVATION", "ELEVATION START", "ELEVATION END",
                                                         "Penetration", "Recovery",
                                                         "LOCATION", "METHOD/DEVICE", 
                                                         "COMMENT"))
   if(any( ! (names(xx$metadata$events)[-1] %in%  
              c("LATITUDE", "LONGITUDE", "ELEVATION",
                "ELEVATION START", "ELEVATION END", 
                "Penetration","Recovery",
                "LOCATION", "METHOD/DEVICE", "COMMENT")))){
    warning(paste('possible missing informatin at metadata-events level for', xx$doi))
   }
   
   ans.ls <- c(list(core_name = names(xx$metadata$events)[1]),
               ans.ls, 
               xx$metadata$events[eventsNames])
   
  # add columns identifying unique source of data for further attribution
  return(as.data.frame(ans.ls, stringsAsFactors = FALSE))
})


```



# LET US TRY MAKING SOME COOL PLOTS!!! - LOCATIONS 
```{r}

# Locations for calibrated ages data plotting

all_Cal_Study.df$LATITUDE <- as.numeric(all_Cal_Study.df$LATITUDE)
all_Cal_Study.df$LONGITUDE <- as.numeric(all_Cal_Study.df$LONGITUDE)

LOCATION <- all_Cal_Study.df %>%
          select(LATITUDE, LONGITUDE, LOCATION) %>%
 filter(is.finite(!is.na(LATITUDE) + is.na(LONGITUDE)))

ggplot() +
  geom_polygon(data = map_data('world'), aes(x = long, y = lat, group = group), fill = "lightgray") +
  geom_point(data = LOCATION, aes(x = LONGITUDE, y = LATITUDE), color = "green", size = 2) +
  labs(x = "Longitude", y = "Latitude") +
  ggtitle("Latitude and Longitude Points on World Map")


# Locations for GEOCHEMISTRY data plotting

allStudy.df$LATITUDE <- as.numeric(allStudy.df$LATITUDE)
allStudy.df$LONGITUDE <- as.numeric(allStudy.df$LONGITUDE)

LOCATION <- allStudy.df %>%
          select(LATITUDE, LONGITUDE, LOCATION) %>%
 filter(is.finite(!is.na(LATITUDE) + is.na(LONGITUDE)))

ggplot() +
  geom_polygon(data = map_data('world'), aes(x = long, y = lat, group = group), fill = "lightgray") +
  geom_point(data = LOCATION, aes(x = LONGITUDE, y = LATITUDE), color = "blue", size = 2) +
  labs(x = "Longitude", y = "Latitude") +
  ggtitle("Latitude and Longitude Points on World Map")


# Locations for AGE DETERMINATION data plotting

all_Age_Study.df$LATITUDE <- as.numeric(all_Age_Study.df$LATITUDE)
all_Age_Study.df$LONGITUDE <- as.numeric(all_Age_Study.df$LONGITUDE)

LOCATION <- all_Age_Study.df %>%
          select(LATITUDE, LONGITUDE, LOCATION) %>%
 filter(is.finite(!is.na(LATITUDE) + is.na(LONGITUDE)))

ggplot() +
  geom_polygon(data = map_data('world'), aes(x = long, y = lat, group = group), fill = "lightgray") +
  geom_point(data = LOCATION, aes(x = LONGITUDE, y = LATITUDE), color = "red", size = 2) +
  labs(x = "Longitude", y = "Latitude") +
  ggtitle("Latitude and Longitude Points on World Map")


```

# LET US MAKE PLOTS FOR THE DEPTH 
```{r}

# Depths for CALIBRATED AGES data plotting
Depth <- all_Cal_Cores.df %>%
          select(`Depth sed [m]`) %>%
 filter(is.finite(!is.na(`Depth sed [m]`)))


# NEEDS A LOT OF WORK!!!
ggplot(data = Depth)
   geom_histogram(aes(x = `Depth sed [m]`))  #make a histrogram
  #facet_wrap(~variable,scales = 'free')




```



```{r}
# write citations as txt file
write.table(sort(PAGES$fullcitation), file="citations_pages.txt", row.names = FALSE, col.names = FALSE, quote = FALSE, sep = "\t", na = "")
```





